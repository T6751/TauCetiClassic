## Введение
**Code Convention** - свод несложных правил по оформлению кода. 
Его наличие подразумевает, что все кто вносят свои изменения, с ним соглашаются и руководствуются им в полной мере. 
Обязательно прочтите всю статью, если зашли сюда в первый раз. Это очень важно.

В случае если что-то не было здесь оговорено, вы можете уточнить этот момент в конфе. Х
отя скорее всего это значит, что в том, что вас интересует вы вольны думать самостоятельно.


## Пробелы и отступы
### Блоки кода
```
В качестве отступов для компилируемых блоков кода используются только табы.
```
```
Если код относится к комментарию (то есть для примера), то выравнивать рекомендуется пробелами.
```
### Процедуры и функции
```
Между вызовом процедуры/функции и скобками не должно быть пробела.
```

<details>
  <summary>Пример</summary>

```
Плохо:
/proc/foo()
	return function (1)

Хорошо:
/proc/foo()
	return function(1)
```
</details>

### Операторы управления (if, while, for и т.д.)
```
Операторы управления (if, while, for и т.д.) Не должны писаться одной строкой.
```
```
Иногда, если так действительно будет лучше, допускается однострочные `switch` и `else if` конструкции.
```

<details>
  <summary>Пример</summary>

```
Плохо:
if(something) return TRUE

for(var/i in something) i.foo()

Хорошо:
if(something)
	return TRUE

for(var/i in something)
	i.foo()

Допустимо:
switch(x)
	if(case_1) foo()
	if(case_2) return FALSE
```
</details>


### Оператор членства (in)
```
В связи с некоторой непредсказуемостью результатов сложных выражений включающих in, любую проверку на наличие в списке стоит брать в скобки.
```


<details>
  <summary>Пример</summary>

```
Плохо:
if(foo && bar in list)

if(bar in arr and foo)

Хорошо:
if(foo && (bar in list))

if((bar in arr) and foo)
```
</details>

### Все остальные операторы (+, -, =, &&, || и т.д.)(и in)
```
Один пробел перед оператором и один пробел после. Исключение - побитовые. Пробелы при их использовании вставляйте на своё усмотрение.
```

<details>
  <summary>Пример</summary>

```
Плохо:
var/a=1
var/b   = 2
var/c =a+b

Хорошо:
var/a = 1
var/b = 2
var/c = a + b
```
</details>

### Скобки и запятые
```
Следуйте единому формату. Так или иначе пробел после запятой - обязателен.
```


<details>
  <summary>Пример</summary>

```
Плохо:
list( 1,2, 3, 4 ,5)

Хорошо:
list(1, 2, 3, 4, 5)

Допустимо:
list( 1 , 2 , 3 , 4 , 5 )
```
</details>

### Комментарии

```
Форматирование только через пробелы. Обратите внимание на выравнивание.
```


<details>
  <summary>Пример</summary>

```
Плохо:
#define A "something"		//	Это что-то.
#define B "anything"	//Это что угодно.

Хорошо:
#define A "something"  // Это что-то.
#define B "anything"   // Это что угодно.
```
</details>

### Выравнивание новых строк
```
Например, при объявлении элементов списка - преимущественно пробелами.
```

<details>
  <summary>Пример</summary>

```
Плохо:
list(1, 2, 3,
	4, 5, 6)

Хорошо:
list(1, 2, 3,
     4, 5, 6)

Допустимо:
list(
	1, 2, 3,
	4, 5, 6
)
```
</details>

## Описание путей
### Абсолютные
```
Все пути в обязательном порядке должны быть абсолютными.
```


<details>
  <summary>Пример</summary>

```
Плохо:
obj
	var
		varname1 = 0
		varname2
	proc
		proc_name()
			code
	item
		weapon
			name = "Weapon"
			proc
				proc_name2()
					..()
					code

Хорошо:
/obj
	var/varname1 = 0
	var/varname2

/obj/proc/proc_name()
	code

/obj/item/weapon
	name = "Weapon"

/obj/item/weapon/proc/proc_name2()
	..()
	code
```
</details>

### Должны начинаться с /

```
Абсолютные пути должны начинаться с /
```

<details>
  <summary>Пример</summary>

```
Плохо:
mob/living

Хорошо:
/mob/living
```
</details>


### Не описываются через текстовую строку

```
Пути не должны описываться через текстовую строку
```

```
Плохо:
var/path = "/obj/item/something"

Хорошо:
var/path = /obj/item/something
```
Записывать путь объекта строкой небезопасно, так как в случае если каким-то образом тот изменится или вообще удалится из билда, компилятор не сообщит о попытке использования несуществующего типа.

## Работа с кодом
### К прочтению:
- [Работа с чатом]
- [Работа с реалтайм событиями]

### Объявление аргументов в процедурах

```
Не должно быть конструкций типа `var/` и `as ...`
```

```
Плохо:
/proc/foo(var/atom/A as area|turf|obj|mob)

Хорошо:
/proc/foo(atom/A)
```

### Оператор `:`

```
Использование оператора : запрещено. Всегда приводите объект к нужному вам типу.
```
```
Плохо:
/proc/foo(atom/A)
	return A:some_var

Хорошо:
/proc/foo(atom/A)
	var/obj/O = A
	return O.some_var
```
Данный оператор отрабатывает в рантайме, проходя по всем подтипам объекта в поисках запрашиваемой переменной, соответственно его использование чревато проблемами производительности. 

```
proc().var и list[index].var - подобные конструкции равнозначны использованию оператора : и их также не следует использовать по тем же причинам.
```

```
Плохо:
var/count = foo().len

Хорошо:
var/list/L = foo()
var/count = L.len
```

### Магические числа
```
Если не знаете что это, то прочитайте эту статью [Магическое число (программирование)](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)). Соответственно их быть не должно. Используйте дефайны или константные переменные.
```
```
Плохо:
/proc/foo(variable)
	switch(variable)
		if(1)
			do something
		if(2)
			return

Хорошо:
#define CASE_1 1
#define CASE_2 2

/proc/foo(variable)
	switch(variable)
		if(CASE_1)
			do something
		if(CASE_2)
			return

#undef CASE_1
#undef CASE_2
```

### Булевский тип
```
Булевский тип: Вместо 1 и 0 используйте `TRUE` и `FALSE` соответственно.
```


### Использование `src`
```
Используйте только тогда, когда это необходимо.
```
```
Плохо:
/mob/some/class/proc/foo()
	src.some_var = some_value
	src.another_var = another_value

Хорошо:
/mob/some/class/proc/foo()
	some_var = some_value
	another_var = another_value

Пример необходимого использования:
/mob/some/class/proc/foo(some_var, another_var)
	src.some_var = some_var
	src.another_var =  another_var
```


### Особенности BYOND
#### Использование `spawn()`

```
Не используйте. В зависимости от используемого спавна есть два пути замены:
- Если spawn(time):
  - Addtimer(CALLBACK(thingtocall, .proc/proc_name, args), time)
  - VARSET_IN(datum, var, var_value, time)
- Если spawn() или spawn(0):
  - Если спавн содержит лишь один прок, то можно убрать спавн а прок записать внутрь INVOKE_ASYNC(). INVOKE_ASYNC(thingtocall, .proc/proc_name, args)
  - Иначе:
  - Обернуть всё, что вызывается внутри спавна в прок и вызывать с помощью INVOKE_ASYNC(thingtocall, .proc/proc_name, args)
  - Обернуть всё, что вызывается внутри спавна в прок, а в самом проке прописать set waitfor = FALSE
```

#### Работа с циклами (black magic)
```
Цикл вида `for(var/i = 1; i <= const_val; i++)` должен быть записан в следующей форме `for(var/i in 1 to const_val)`.
```
Причина: второй цикл работает быстрее. Почему? Хороший вопрос, стоит задать его кодерам BYOND. У обоих видов одинаковое поведение, но у второго есть нюансы. `to` тоже самое, что и `<=`, соответственно чтобы было `<` нужно сделать `for(var/i in 1 to const_val - 1)`. Ещё важный момент - `const_val` переменная не должна быть изменена во время цикла. То есть если вы делаете проход по списку, который изменяется внутри цикла, а `const_val` размер списка, то вам нужно использовать классический, первый, вариант.
